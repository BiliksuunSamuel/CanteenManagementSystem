<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Dapplo.Windows</name>
    </assembly>
    <members>
        <member name="T:Dapplo.Windows.App.AppQuery">
            <summary>
                Helper class to support with Windows Store apps
            </summary>
        </member>
        <member name="F:Dapplo.Windows.App.AppQuery.AppWindowClass">
            <summary>
            Used for Windows 8(.1) and Windows 10 (but as child of "ApplicationFrameWindow")
            </summary>
        </member>
        <member name="F:Dapplo.Windows.App.AppQuery.AppFrameWindowClass">
            <summary>
            Windows 10 uses ApplicationFrameWindow to host the App
            </summary>
        </member>
        <member name="P:Dapplo.Windows.App.AppQuery.AppLauncher">
            <summary>
                Get the hWnd for the AppLauncer
            </summary>
        </member>
        <member name="P:Dapplo.Windows.App.AppQuery.IsLauncherVisible">
            <summary>
                Return true if the app-launcher is visible
            </summary>
        </member>
        <member name="P:Dapplo.Windows.App.AppQuery.WindowsStoreApps">
            <summary>
                Retrieve handles of all Windows store apps
            </summary>
        </member>
        <member name="M:Dapplo.Windows.App.AppQuery.AppVisible(Dapplo.Windows.Common.Structs.NativeRect)">
            <summary>
                Check if a Windows Store App (WinRT) is visible
            </summary>
            <param name="windowBounds"></param>
            <returns>true if an app, covering the supplied rect, is visisble</returns>
        </member>
        <member name="M:Dapplo.Windows.App.AppQuery.GetAppLauncher">
            <summary>
                Get the AppLauncher
            </summary>
            <returns>IInteropWindow</returns>
        </member>
        <member name="M:Dapplo.Windows.App.AppQuery.IsApp(Dapplo.Windows.Desktop.IInteropWindow)">
            <summary>
                This checks if the window is an App (Win8 or Win10)
            </summary>
        </member>
        <member name="M:Dapplo.Windows.App.AppQuery.IsAppLauncher(Dapplo.Windows.Desktop.IInteropWindow)">
            <summary>
                Test if this window is for the App-Launcher
            </summary>
        </member>
        <member name="M:Dapplo.Windows.App.AppQuery.IsGutter(Dapplo.Windows.Desktop.IInteropWindow)">
            <summary>
                Check if the window is the metro gutter (sizeable separator)
            </summary>
        </member>
        <member name="M:Dapplo.Windows.App.AppQuery.IsWin10App(Dapplo.Windows.Desktop.IInteropWindow)">
            <summary>
                This checks if the window is a Windows 10 App
                For Windows 10 apps are hosted inside "ApplicationFrameWindow"
            </summary>
        </member>
        <member name="M:Dapplo.Windows.App.AppQuery.IsBackgroundWin10App(Dapplo.Windows.Desktop.IInteropWindow)">
            <summary>
                This checks if the window is a Windows 10 App
                For Windows 10 apps are hosted inside "ApplicationFrameWindow"
            </summary>
        </member>
        <member name="M:Dapplo.Windows.App.AppQuery.IsWin8App(Dapplo.Windows.Desktop.IInteropWindow)">
            <summary>
                This checks if the window is a Windows 8 App, not Win 10!
            </summary>
        </member>
        <member name="T:Dapplo.Windows.App.MonitorAppVisibility">
            <summary>
                A simple enum for the GetAppVisibilityOnMonitor method, this tells us if an App is visible on the supplied monitor.
            </summary>
        </member>
        <member name="T:Dapplo.Windows.Desktop.EnvironmentChangedEventArgs">
            <summary>
                Event arguments for the WM_SETTINGCHANGE message
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Desktop.EnvironmentChangedEventArgs.Area">
            <summary>
                When the system sends this message as a result of a SystemParametersInfo call, lParam is a pointer to a string that
                indicates the area containing the system parameter that was changed. This parameter does not usually indicate which
                specific system parameter changed. (Note that some applications send this message with lParam set to NULL.) In
                general, when you receive this message, you should check and reload any system parameter settings that are used by
                your application.
                This string can be the name of a registry key or the name of a section in the Win.ini file. When the string is a
                registry name, it typically indicates only the leaf node in the registry, not the full path.
                When the system sends this message as a result of a change in policy settings, this parameter points to the string
                "Policy".
                When the system sends this message as a result of a change in locale settings, this parameter points to the string
                "intl".
                To effect a change in the environment variables for the system or the user, broadcast this message with lParam set
                to the string "Environment".
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Desktop.EnvironmentChangedEventArgs.SystemParametersInfoAction">
            <summary>
                When the system sends this message as a result of a SystemParametersInfo call, the wParam parameter is the value of
                the uiAction parameter passed to the SystemParametersInfo function. For a list of values, see SystemParametersInfo.
                When the system sends this message as a result of a change in policy settings, this parameter indicates the type of
                policy that was applied. This value is 1 if computer policy was applied or zero if user policy was applied.
                When the system sends this message as a result of a change in locale settings, this parameter is zero.
                When an application sends this message, this parameter must be NULL.
            </summary>
        </member>
        <member name="M:Dapplo.Windows.Desktop.EnvironmentChangedEventArgs.Create(Dapplo.Windows.User32.Enums.SystemParametersInfoActions,System.String)">
            <summary>
                Factory for the EnvironmentChangedEventArgs
            </summary>
            <returns></returns>
        </member>
        <member name="T:Dapplo.Windows.Desktop.IInteropWindow">
            <summary>
                This is the interface of all classes which represent a native window
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Desktop.IInteropWindow.CanScroll">
            <summary>
                Specifies if a WindowScroller can work with this window
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Desktop.IInteropWindow.Caption">
            <summary>
                Return the title of the window, if any
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Desktop.IInteropWindow.Children">
            <summary>
                Returns the children of this window
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Desktop.IInteropWindow.Classname">
            <summary>
                string with the name of the internal class for the window
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Desktop.IInteropWindow.Handle">
            <summary>
                Handle (ID) of the window
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Desktop.IInteropWindow.HasZOrderedChildren">
            <summary>
            Checks if the children are retrieved in a Z-Order
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Desktop.IInteropWindow.HasChildren">
            <summary>
                Test if there are any children
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Desktop.IInteropWindow.HasClassname">
            <summary>
                Does the window have a classname?
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Desktop.IInteropWindow.HasParent">
            <summary>
                Does this window have parent?
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Desktop.IInteropWindow.Info">
            <summary>
                WindowInfo for the Window
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Desktop.IInteropWindow.IsMaximized">
            <summary>
                Returns true if the window is maximized
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Desktop.IInteropWindow.IsMinimized">
            <summary>
                Returns true if the window is minimized
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Desktop.IInteropWindow.IsVisible">
            <summary>
                Returns true if the window is visible
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Desktop.IInteropWindow.Parent">
            <summary>
                The handle for the parent to which this window belongs
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Desktop.IInteropWindow.ParentWindow">
            <summary>
                The actually IInteropWindow for the parent.
                This is filled when this window was retrieved via parent.GetChildren or parent.GetZOrderChildren
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Desktop.IInteropWindow.Placement">
            <summary>
                WindowPlacement for the Window
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Desktop.IInteropWindow.ThreadId">
            <summary>
                Get the thread ID this window belongs to, read with GetProcessId()
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Desktop.IInteropWindow.ProcessId">
            <summary>
                Get the process ID this window belongs to, read with GetProcessId()
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Desktop.IInteropWindow.Text">
            <summary>
                Return the text (not title) of the window, if any
            </summary>
        </member>
        <member name="M:Dapplo.Windows.Desktop.IInteropWindow.Dump(Dapplo.Windows.Enums.InteropWindowRetrieveSettings,System.Text.StringBuilder,System.String)">
            <summary>
                Dump the information in the InteropWindow for debugging
            </summary>
            <param name="retrieveSettings">InteropWindowRetrieveSettings to specify what to dump</param>
            <param name="dump">StringBuilder to dump to</param>
            <param name="indentation">int</param>
            <returns>StringBuilder</returns>
        </member>
        <member name="T:Dapplo.Windows.Desktop.InteropWindow">
            <summary>
                Information about a native window
                Note: This is a dumb container, and doesn't retrieve anything about the window itself
            </summary>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindow.#ctor(System.IntPtr)">
            <summary>
            Create an InteropWindow for the specified windows handle
            </summary>
            <param name="handle">IntPtr</param>
        </member>
        <member name="P:Dapplo.Windows.Desktop.InteropWindow.Handle">
            <inheritdoc />
        </member>
        <member name="P:Dapplo.Windows.Desktop.InteropWindow.HasZOrderedChildren">
            <inheritdoc />
        </member>
        <member name="P:Dapplo.Windows.Desktop.InteropWindow.Info">
            <inheritdoc />
        </member>
        <member name="P:Dapplo.Windows.Desktop.InteropWindow.Children">
            <inheritdoc />
        </member>
        <member name="P:Dapplo.Windows.Desktop.InteropWindow.HasChildren">
            <inheritdoc />
        </member>
        <member name="P:Dapplo.Windows.Desktop.InteropWindow.Classname">
            <inheritdoc />
        </member>
        <member name="P:Dapplo.Windows.Desktop.InteropWindow.HasClassname">
            <inheritdoc />
        </member>
        <member name="P:Dapplo.Windows.Desktop.InteropWindow.HasParent">
            <inheritdoc />
        </member>
        <member name="P:Dapplo.Windows.Desktop.InteropWindow.Parent">
            <inheritdoc />
        </member>
        <member name="P:Dapplo.Windows.Desktop.InteropWindow.ParentWindow">
            <inheritdoc />
        </member>
        <member name="P:Dapplo.Windows.Desktop.InteropWindow.Caption">
            <inheritdoc />
        </member>
        <member name="P:Dapplo.Windows.Desktop.InteropWindow.Text">
            <inheritdoc />
        </member>
        <member name="P:Dapplo.Windows.Desktop.InteropWindow.IsVisible">
            <inheritdoc />
        </member>
        <member name="P:Dapplo.Windows.Desktop.InteropWindow.IsMinimized">
            <inheritdoc />
        </member>
        <member name="P:Dapplo.Windows.Desktop.InteropWindow.IsMaximized">
            <inheritdoc />
        </member>
        <member name="P:Dapplo.Windows.Desktop.InteropWindow.ThreadId">
            <inheritdoc />
        </member>
        <member name="P:Dapplo.Windows.Desktop.InteropWindow.ProcessId">
            <inheritdoc />
        </member>
        <member name="P:Dapplo.Windows.Desktop.InteropWindow.Placement">
            <inheritdoc />
        </member>
        <member name="P:Dapplo.Windows.Desktop.InteropWindow.CanScroll">
            <inheritdoc />
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindow.Dump(Dapplo.Windows.Enums.InteropWindowRetrieveSettings,System.Text.StringBuilder,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindow.Equals(Dapplo.Windows.Desktop.IInteropWindow)">
            <inheritdoc />
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindow.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindow.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindow.op_Equality(Dapplo.Windows.Desktop.InteropWindow,Dapplo.Windows.Desktop.InteropWindow)">
            <summary>
            Operator == overload
            </summary>
            <param name="left">InteropWindow</param>
            <param name="right">InteropWindow</param>
            <returns>bool</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindow.op_Implicit(System.IntPtr)~Dapplo.Windows.Desktop.InteropWindow">
            <summary>
            Create (cast) a InteropWindow from an IntPtr
            </summary>
            <param name="handle">IntPtr</param>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindow.op_Implicit(Dapplo.Windows.Desktop.InteropWindow)~System.IntPtr">
            <summary>
            Cast the InteropWindow to it's handle
            </summary>
            <param name="interopWindow">InteropWindow</param>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindow.op_Inequality(Dapplo.Windows.Desktop.InteropWindow,Dapplo.Windows.Desktop.InteropWindow)">
            <summary>
            operator != overload
            </summary>
            <param name="left">InteropWindow</param>
            <param name="right">InteropWindow</param>
            <returns>bool</returns>
        </member>
        <member name="T:Dapplo.Windows.Desktop.InteropWindowExtensions">
            <summary>
                Extensions for the interopWindow, all get or set commands update the value in the InteropWindow that is used.
            </summary>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowExtensions.Exists(Dapplo.Windows.Desktop.IInteropWindow)">
            <summary>
            Tests if the interopWindow still exists
            </summary>
            <param name="interopWindow">IInteropWindow</param>
            <returns>True if it's still there.
            Because window handles are recycled the handle could point to a different window!
            </returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowExtensions.Fill(Dapplo.Windows.Desktop.IInteropWindow,Dapplo.Windows.Enums.InteropWindowRetrieveSettings)">
            <summary>
                Fill ALL the information of the InteropWindow
            </summary>
            <param name="interopWindow">InteropWindow</param>
            <param name="retrieveSettings">InteropWindowRetrieveSettings to specify which information is retrieved and what not</param>
            <returns>IInteropWindow for fluent calls</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowExtensions.GetCaption(Dapplo.Windows.Desktop.IInteropWindow,System.Boolean)">
            <summary>
                Get the Windows caption (title)
            </summary>
            <param name="interopWindow">InteropWindow</param>
            <param name="forceUpdate">set to true to make sure the value is updated</param>
            <returns>string with the caption</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowExtensions.GetChildren(Dapplo.Windows.Desktop.IInteropWindow,System.Boolean)">
            <summary>
                Get the children of the specified interopWindow, this is not lazy!
            </summary>
            <param name="interopWindow">InteropWindow</param>
            <param name="forceUpdate">True to force updating</param>
            <returns>IEnumerable with InteropWindow</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowExtensions.GetClassname(Dapplo.Windows.Desktop.IInteropWindow,System.Boolean)">
            <summary>
                Get the Windows class name
            </summary>
            <param name="interopWindow">InteropWindow</param>
            <param name="forceUpdate">set to true to make sure the value is updated</param>
            <returns>string with the classname</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowExtensions.GetInfo(Dapplo.Windows.Desktop.IInteropWindow,System.Boolean,System.Boolean)">
            <summary>
                Get the WindowInfo
            </summary>
            <param name="interopWindow">InteropWindow</param>
            <param name="forceUpdate">set to true to make sure the value is updated</param>
            <param name="autoCorrect">enable auto correction, e,g, have the bounds cropped to the parent(s)</param>
            <returns>WindowInfo</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowExtensions.GetParent(Dapplo.Windows.Desktop.IInteropWindow,System.Boolean)">
            <summary>
                Get the parent
            </summary>
            <param name="interopWindow">InteropWindow</param>
            <param name="forceUpdate">set to true to make sure the value is updated</param>
            <returns>IntPtr for the parent</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowExtensions.GetParentWindow(Dapplo.Windows.Desktop.IInteropWindow,System.Boolean)">
            <summary>
                Get the parent IInteropWindow
            </summary>
            <param name="interopWindow">InteropWindow</param>
            <param name="forceUpdate">set to true to make sure the value is updated</param>
            <returns>IInteropWindow for the parent</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowExtensions.GetPlacement(Dapplo.Windows.Desktop.IInteropWindow,System.Boolean)">
            <summary>
                Get the WindowPlacement
            </summary>
            <param name="interopWindow">InteropWindow</param>
            <param name="forceUpdate">set to true to make sure the value is updated</param>
            <returns>WindowPlacement</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowExtensions.GetProcessId(Dapplo.Windows.Desktop.IInteropWindow,System.Boolean)">
            <summary>
                Get the process and thread which the specified window belongs to, the value is cached into the ProcessId of the WindowInfo
            </summary>
            <param name="interopWindow">InteropWindow</param>
            <param name="forceUpdate">set to true to make sure the value is updated</param>
            <returns>uint with process Id</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowExtensions.GetRegion(Dapplo.Windows.Desktop.IInteropWindow)">
            <summary>
                Get the region for a window
            </summary>
            <param name="interopWindow">InteropWindow</param>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowExtensions.GetText(Dapplo.Windows.Desktop.IInteropWindow,System.Boolean)">
            <summary>
                Get text from the window
            </summary>
            <param name="interopWindow">InteropWindow</param>
            <param name="forceUpdate">set to true to make sure the value is updated</param>
            <returns>string with the text</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowExtensions.GetWindowScroller(Dapplo.Windows.Desktop.IInteropWindow,Dapplo.Windows.User32.Enums.ScrollBarTypes,System.Boolean)">
            <summary>
                Extension method to create a WindowScroller
            </summary>
            <param name="interopWindow">IInteropWindow</param>
            <param name="scrollBarType">ScrollBarTypes</param>
            <param name="forceUpdate">true to force a retry, even if the previous check failed</param>
            <returns>WindowScroller or null</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowExtensions.GetZOrderedChildren(Dapplo.Windows.Desktop.IInteropWindow,System.Boolean)">
            <summary>
                Get the children of the specified interopWindow, from top to bottom. This is not lazy
                This might get different results than the GetChildren
            </summary>
            <param name="interopWindow">InteropWindow</param>
            <param name="forceUpdate">True to force updating</param>
            <returns>IEnumerable with InteropWindow</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowExtensions.IsDockedToLeftOf(Dapplo.Windows.Desktop.IInteropWindow,Dapplo.Windows.Desktop.IInteropWindow,System.Func{Dapplo.Windows.Desktop.IInteropWindow,Dapplo.Windows.Common.Structs.NativeRect})">
            <summary>
                Returns if the IInteropWindow is docked to the left of the other IInteropWindow
            </summary>
            <param name="window1">IInteropWindow</param>
            <param name="window2">IInteropWindow</param>
            <param name="retrieveBoundsFunc">Function which returns the bounds for the IInteropWindow</param>
            <returns>bool true if docked</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowExtensions.IsDockedToRightOf(Dapplo.Windows.Desktop.IInteropWindow,Dapplo.Windows.Desktop.IInteropWindow,System.Func{Dapplo.Windows.Desktop.IInteropWindow,Dapplo.Windows.Common.Structs.NativeRect})">
            <summary>
                Returns if the IInteropWindow is docked to the left of the other IInteropWindow
            </summary>
            <param name="window1">IInteropWindow</param>
            <param name="window2">IInteropWindow</param>
            <param name="retrieveBoundsFunc">Function which returns the bounds for the IInteropWindow</param>
            <returns>bool true if docked</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowExtensions.IsMaximized(Dapplo.Windows.Desktop.IInteropWindow,System.Boolean)">
            <summary>
                Retrieve if the window is maximized (Iconic)
            </summary>
            <param name="interopWindow">InteropWindow</param>
            <param name="forceUpdate">set to true to make sure the value is updated</param>
            <returns>bool true if Iconic (minimized)</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowExtensions.IsMinimized(Dapplo.Windows.Desktop.IInteropWindow,System.Boolean)">
            <summary>
                Retrieve if the window is minimized (Iconic)
            </summary>
            <param name="interopWindow">InteropWindow</param>
            <param name="forceUpdate">set to true to make sure the value is updated</param>
            <returns>bool true if Iconic (minimized)</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowExtensions.IsVisible(Dapplo.Windows.Desktop.IInteropWindow,System.Boolean)">
            <summary>
                Retrieve if the window is Visible and not cloaked (different desktop)
            </summary>
            <param name="interopWindow">InteropWindow</param>
            <param name="forceUpdate">set to true to make sure the value is updated</param>
            <returns>bool true if minimizedIconic (minimized)</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowExtensions.IsOwnedByCurrentProcess(Dapplo.Windows.Desktop.IInteropWindow)">
            <summary>
                Test if the window is owned by the current process
            </summary>
            <param name="interopWindow">InteropWindow</param>
            <returns>bool true if the window is owned by the current process</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowExtensions.IsOwnedByCurrentThread(Dapplo.Windows.Desktop.IInteropWindow)">
            <summary>
                Test if the window is owned by the current thread
            </summary>
            <param name="interopWindow">InteropWindow</param>
            <returns>bool true if the window is owned by the current thread</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowExtensions.Maximize(Dapplo.Windows.Desktop.IInteropWindow)">
            <summary>
                Maximize the window
            </summary>
            <param name="interopWindow">InteropWindow</param>
            <returns>IInteropWindow for fluent calls</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowExtensions.Minimize(Dapplo.Windows.Desktop.IInteropWindow)">
            <summary>
                Minimize the Window
            </summary>
            <param name="interopWindow">InteropWindow</param>
            <returns>IInteropWindow for fluent calls</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowExtensions.Restore(Dapplo.Windows.Desktop.IInteropWindow)">
            <summary>
                Restore (Un-Minimize/Maximize) the Window
            </summary>
            <param name="interopWindow">InteropWindow</param>
            <returns>IInteropWindow for fluent calls</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowExtensions.SetExtendedStyle(Dapplo.Windows.Desktop.IInteropWindow,Dapplo.Windows.User32.Enums.ExtendedWindowStyleFlags)">
            <summary>
                Set the Extended WindowStyle
            </summary>
            <param name="interopWindow">InteropWindow</param>
            <param name="extendedWindowStyleFlags">ExtendedWindowStyleFlags</param>
            <returns>IInteropWindow for fluent calls</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowExtensions.SetStyle(Dapplo.Windows.Desktop.IInteropWindow,Dapplo.Windows.User32.Enums.WindowStyleFlags)">
            <summary>
                Set the WindowStyle
            </summary>
            <param name="interopWindow">InteropWindow</param>
            <param name="windowStyleFlags">WindowStyleFlags</param>
            <returns>IInteropWindow for fluent calls</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowExtensions.SetPlacement(Dapplo.Windows.Desktop.IInteropWindow,Dapplo.Windows.User32.Structs.WindowPlacement)">
            <summary>
                Set the WindowPlacement
            </summary>
            <param name="interopWindow">InteropWindow</param>
            <param name="placement">WindowPlacement</param>
            <returns>IInteropWindow for fluent calls</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowExtensions.ToForegroundAsync(Dapplo.Windows.Desktop.IInteropWindow)">
            <summary>
                Set the window as foreground window
            </summary>
            <param name="interopWindow">The window to bring to the foreground</param>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowExtensions.MoveTo(Dapplo.Windows.Desktop.IInteropWindow,Dapplo.Windows.Common.Structs.NativePoint)">
            <summary>
            Move the specified window to a new location
            </summary>
            <param name="interopWindow">IInteropWindow</param>
            <param name="location">NativePoint with the offset</param>
            <returns>IInteropWindow for fluent calls</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowExtensions.GetLinkedWindows(Dapplo.Windows.Desktop.IInteropWindow)">
            <summary>
            Get all the other windows belonging to the process which owns the specified window
            </summary>
            <param name="windowToLinkTo">IInteropWindow</param>
            <returns>IEnumerable of IInteropWindow</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowExtensions.GetVisibleLocation(Dapplo.Windows.Desktop.IInteropWindow,Dapplo.Windows.Common.Structs.NativePoint@)">
            <summary>
                Get a location where this window would be visible
                * if none is found return false, formLocation = the original location
                * if something is found, return true and formLocation = new location
            </summary>
            <param name="interopWindow">IInteropWindow, the window to find a location for</param>
            <param name="formLocation">NativePoint with the location where the window will fit</param>
            <returns>true if a location if found, and the formLocation is also set</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowExtensions.PrintWindow``1(Dapplo.Windows.Desktop.IInteropWindow)">
            <summary>
            Return an Image representing the Window!
            As GDI+ draws it, it will be without Aero borders!
            </summary>
        </member>
        <member name="T:Dapplo.Windows.Desktop.InteropWindowFactory">
            <summary>
                Factory for InteropWindows
            </summary>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowFactory.CreateFor(System.Int32)">
            <summary>
                Factory method to create a InteropWindow for the supplied handle
            </summary>
            <param name="handle">int</param>
            <returns>InteropWindow</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowFactory.CreateFor(System.IntPtr)">
            <summary>
                Factory method to create a InteropWindow for the supplied handle
            </summary>
            <param name="handle">IntPtr</param>
            <returns>InteropWindow</returns>
        </member>
        <member name="T:Dapplo.Windows.Desktop.InteropWindowQuery">
            <summary>
                Query for native windows
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Desktop.InteropWindowQuery.IgnoreClasses">
            <summary>
                Window classes which can be ignored
            </summary>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowQuery.GetForegroundWindow">
            <summary>
                Get the window with which the user is currently working
            </summary>
            <returns>IInteropWindow</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowQuery.GetDesktopWindow">
            <summary>
                Gets the Desktop window
            </summary>
            <returns>IInteropWindow for the desktop window</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowQuery.GetWindowsForProcess(System.Int32)">
            <summary>
                Find windows belonging to the same process (thread) as the process ID.
            </summary>
            <param name="processId">int with process Id</param>
            <returns>IEnumerable with IInteropWindow</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowQuery.GetTopLevelWindows(System.Boolean)">
            <summary>
                Iterate the Top level windows, from top to bottom
            </summary>
            <param name="ignoreKnownClasses">true to ignore windows with certain known classes</param>
            <returns>IEnumerable with all the top level windows</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowQuery.GetTopWindows(Dapplo.Windows.Desktop.IInteropWindow)">
            <summary>
                Iterate the windows, from top to bottom
            </summary>
            <param name="parent">InteropWindow as the parent, to iterate over the children, or null for all</param>
            <returns>IEnumerable with all the top level windows</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowQuery.CanIgnoreClass(Dapplo.Windows.Desktop.IInteropWindow)">
            <summary>
            Check the Classname of the IInteropWindow against a list of know classes which can be ignored.
            </summary>
            <param name="interopWindow">IInteropWindow</param>
            <returns>bool</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowQuery.IsPopup(Dapplo.Windows.Desktop.IInteropWindow,System.Boolean)">
            <summary>
            Is the specified window a visible popup
            </summary>
            <param name="interopWindow">IInteropWindow</param>
            <param name="ignoreKnowClasses">true (default) to ignore some known internal windows classes</param>
            <returns>true if the IInteropWindow is a popup</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.InteropWindowQuery.IsTopLevel(Dapplo.Windows.Desktop.IInteropWindow,System.Boolean)">
            <summary>
                Check if the window is a top level window.
                This method will retrieve all information, and fill it to the interopWindow, it needs to make the decision.
            </summary>
            <param name="interopWindow">InteropWindow</param>
            <param name="ignoreKnowClasses">true (default) to ignore classes from the IgnoreClasses list</param>
            <returns>bool</returns>
        </member>
        <member name="T:Dapplo.Windows.Desktop.WindowScroller">
            <summary>
                The is a container class to help to scroll a window
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Desktop.WindowScroller.InitialScrollInfo">
            <summary>
                This is used to be able to reset the location, and also detect if we are at the end.
                Some windows might add content when the user is (almost) at the end.
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Desktop.WindowScroller.IsAtEnd">
            <summary>
                Returns true if the scroller is at the end
            </summary>
            <returns>bool</returns>
        </member>
        <member name="P:Dapplo.Windows.Desktop.WindowScroller.IsAtStart">
            <summary>
                Returns true if the scroller is at the start
            </summary>
            <returns>bool</returns>
        </member>
        <member name="P:Dapplo.Windows.Desktop.WindowScroller.KeepInitialBounds">
            <summary>
                Some windows might add content when the user is (almost) at the end.
                If this is true, the scrolling doesn't go beyond the intial bounds.
                If this is false, the initial value is only used for reset.
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Desktop.WindowScroller.ScrollBar">
            <summary>
                Get the information on the used scrollbar, if any.
                This can be used to detect the location of the scrollbar
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Desktop.WindowScroller.ScrollBarType">
            <summary>
                What scrollbar to use
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Desktop.WindowScroller.ScrollBarWindow">
            <summary>
                Area of the scrollbar, this can be the WindowToScroll
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Desktop.WindowScroller.ScrollingWindow">
            <summary>
                Area which is scrolling, can be the WindowToScroll
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Desktop.WindowScroller.ScrollMode">
            <summary>
                Specify which scroll mode needs to be used
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Desktop.WindowScroller.ScrollWheelLinesFromRegistry">
            <summary>
                Get the scroll-lines from the registry
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Desktop.WindowScroller.ShowChanges">
            <summary>
                Does the scrollbar need to represent the changes?
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Desktop.WindowScroller.WheelDelta">
            <summary>
                Amount of delta the scrollwheel scrolls
            </summary>
        </member>
        <member name="M:Dapplo.Windows.Desktop.WindowScroller.ApplyPosition(Dapplo.Windows.User32.Structs.ScrollInfo@)">
            <summary>
                Apply position from the scrollInfo
            </summary>
            <param name="scrollInfo">SCROLLINFO ref</param>
            <returns>bool</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.WindowScroller.End">
            <summary>
                Move to the end
            </summary>
            <returns>bool if this worked</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.WindowScroller.GetPosition(Dapplo.Windows.User32.Structs.ScrollInfo@)">
            <summary>
                Get current position
            </summary>
            <returns>SCROLLINFO</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.WindowScroller.GetScrollbarInfo(System.Boolean)">
            <summary>
                Method to set the ScrollbarInfo, if we can get it
            </summary>
            <param name="forceUpdate">set to true to force an update, default is false</param>
            <returns>ScrollBarInfo?</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.WindowScroller.NeedsFocus">
            <summary>
                Returns true if the window needs focus to scroll
            </summary>
            <returns>true if focus is needed</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.WindowScroller.Next">
            <summary>
                Go to the next "page"
            </summary>
            <returns>bool if this worked</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.WindowScroller.Previous">
            <summary>
                Go to the previous "page"
            </summary>
            <returns>bool if this worked</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.WindowScroller.Reset">
            <summary>
                Set the position back to the original, only works for windows which support ScrollModes.WindowsMessage
            </summary>
            <returns>true if this worked</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.WindowScroller.SendScrollMessage(Dapplo.Windows.User32.Enums.ScrollBarCommands)">
            <summary>
                Helper method to send the right message
            </summary>
            <param name="scrollBarCommand">ScrollBarCommands enum to specify where to scroll</param>
            <returns>true if this was possible</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.WindowScroller.Start">
            <summary>
                Move to the start
            </summary>
            <returns>bool if this worked</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.WindowScroller.TryRetrievePosition(Dapplo.Windows.User32.Structs.ScrollInfo@)">
            <summary>
                Retrieve position from the scrollInfo
            </summary>
            <param name="scrollInfo">ScrollInfo out</param>
            <returns>bool</returns>
        </member>
        <member name="T:Dapplo.Windows.Desktop.WindowsEnumerator">
            <summary>
                A managed EnumWindows wrapper, offering both as IObservable as an IEnumerable
            </summary>
        </member>
        <member name="M:Dapplo.Windows.Desktop.WindowsEnumerator.EnumerateWindowHandles(Dapplo.Windows.Desktop.IInteropWindow,System.Func{System.IntPtr,System.Boolean},System.Func{System.IntPtr,System.Int32,System.Boolean})">
            <summary>
                Enumerate the windows / child windows (this is NOT lazy, unless you add functions)
            </summary>
            <param name="parent">IInteropWindow with the hWnd of the parent, or null for all</param>
            <param name="wherePredicate">Func for the where</param>
            <param name="takeWhileFunc">Func which can decide to stop enumerating, the second argument is the current count</param>
            <returns>IEnumerable with IntPtr</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.WindowsEnumerator.EnumerateWindows(Dapplo.Windows.Desktop.IInteropWindow,System.Func{Dapplo.Windows.Desktop.IInteropWindow,System.Boolean},System.Func{Dapplo.Windows.Desktop.IInteropWindow,System.Int32,System.Boolean})">
            <summary>
                Enumerate the windows / child windows (this is NOT lazy)
            </summary>
            <param name="parent">IInteropWindow with the hWnd of the parent, or null for all</param>
            <param name="wherePredicate">Func for the where</param>
            <param name="takeWhileFunc">Func which can decide to stop enumerating, the second argument is the current count</param>
            <returns>IEnumerable with InteropWindow</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.WindowsEnumerator.EnumerateWindowsAsync(System.Nullable{System.IntPtr})">
            <summary>
                Enumerate the windows / child windows via an Observable
            </summary>
            <param name="hWndParent">IntPtr with the hWnd of the parent, or null for all</param>
            <returns>IObservable with IInteropWindow</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.WindowsEnumerator.EnumerateWindowHandlesAsync(System.Nullable{System.IntPtr})">
            <summary>
                Enumerate the windows and child handles (IntPtr) via an Observable
            </summary>
            <param name="hWndParent">IntPtr with the hWnd of the parent, or null for all</param>
            <returns>IObservable with IntPtr</returns>
        </member>
        <member name="T:Dapplo.Windows.Desktop.WinEventHook">
            <summary>
                The WinEventHook can register handlers to become important windows events
                This makes it possible to know a.o. when a window is created, moved, updated and closed.
                Make sure you have a message pump running (WinProc), otherwise the behavior is sporadic / none.
            </summary>
        </member>
        <member name="M:Dapplo.Windows.Desktop.WinEventHook.Create(Dapplo.Windows.Enums.WinEvents,System.Nullable{Dapplo.Windows.Enums.WinEvents},System.Int32,System.Int32)">
            <summary>
                Create a WinEventHook as observable
            </summary>
            <param name="winEventStart">WinEvent "start" of which you are interested</param>
            <param name="winEventEnd">WinEvent "end" of which you are interested</param>
            <param name="process"></param>
            <param name="thread"></param>
            <returns>IObservable which processes WinEventInfo</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.WinEventHook.WindowTitleChangeObservable">
            <summary>
                Create an observable which only monitors title changes
            </summary>
            <returns>IObservable with WinEventInfo</returns>
        </member>
        <member name="M:Dapplo.Windows.Desktop.WinEventHook.SetWinEventHook(Dapplo.Windows.Enums.WinEvents,Dapplo.Windows.Enums.WinEvents,System.IntPtr,Dapplo.Windows.Desktop.WinEventHook.WinEventDelegate,System.Int32,System.Int32,Dapplo.Windows.Enums.WinEventHookFlags)">
            <summary>
                Hook to win events
            </summary>
            <param name="eventMin">
                Specifies the event constant for the lowest event value in the range of events that are handled
                by the hook function. This parameter can be set to EVENT_MIN to indicate the lowest possible event value.
            </param>
            <param name="eventMax">
                Specifies the event constant for the highest event value in the range of events that are handled
                by the hook function. This parameter can be set to EVENT_MAX to indicate the highest possible event value.
            </param>
            <param name="hmodWinEventProc">
                Handle to the DLL that contains the hook function at lpfnWinEventProc, if the
                WINEVENT_INCONTEXT flag is specified in the dwFlags parameter. If the hook function is not located in a DLL, or if
                the WINEVENT_OUTOFCONTEXT flag is specified, this parameter is NULL.
            </param>
            <param name="eventProc">WinEventDelegate</param>
            <param name="idProcess">
                Specifies the ID of the process from which the hook function receives events. Specify zero (0)
                to receive events from all processes on the current desktop.
            </param>
            <param name="idThread">
                Specifies the ID of the thread from which the hook function receives events. If this parameter
                is zero, the hook function is associated with all existing threads on the current desktop.
            </param>
            <param name="winEventHookFlags">WinEventHookFlags</param>
            <returns>IntPtr with the hook id</returns>
        </member>
        <member name="T:Dapplo.Windows.Desktop.WinEventHook.WinEventDelegate">
            <summary>
                The delegate called by SetWinEventHook when an event occurs
            </summary>
            <param name="hWinEventHook">IntPtr with the eventhook that this call belongs to</param>
            <param name="eventType">WinEvent</param>
            <param name="hWnd">IntPtr</param>
            <param name="idObject">ObjectIdentifiers</param>
            <param name="idChild">int</param>
            <param name="eventThread">uint with EventThread</param>
            <param name="eventTime">uint with EventTime</param>
        </member>
        <member name="T:Dapplo.Windows.Enums.InteropWindowRetrieveSettings">
            <summary>
                These flags define which values are retrieved and if they are cached or not
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.InteropWindowRetrieveSettings.None">
            <summary>
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.InteropWindowRetrieveSettings.ForceUpdate">
            <summary>
                Forces an update of the specified flags.
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.InteropWindowRetrieveSettings.Info">
            <summary>
                Retrieve the WindowInfo
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.InteropWindowRetrieveSettings.Caption">
            <summary>
                Retrieve the caption
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.InteropWindowRetrieveSettings.Classname">
            <summary>
                Retrieve the class name
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.InteropWindowRetrieveSettings.ProcessId">
            <summary>
                Retrieve the matching process id
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.InteropWindowRetrieveSettings.Parent">
            <summary>
                Retrieve the parent
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.InteropWindowRetrieveSettings.Placement">
            <summary>
                Retrieve the placement
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.InteropWindowRetrieveSettings.Visible">
            <summary>
                Retrieve the is visible
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.InteropWindowRetrieveSettings.Maximized">
            <summary>
                Retrieve the zoom state (maximized)
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.InteropWindowRetrieveSettings.Minimized">
            <summary>
                Retrieve the icon state (minimized)
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.InteropWindowRetrieveSettings.Text">
            <summary>
                Retrieve the text
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.InteropWindowRetrieveSettings.ScrollInfo">
            <summary>
                Retrieve the scroll info
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.InteropWindowRetrieveSettings.Children">
            <summary>
                Retrieve the children
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.InteropWindowRetrieveSettings.ZOrderedChildren">
            <summary>
                Retrieve the children by z-order
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.InteropWindowRetrieveSettings.AutoCorrectValues">
            <summary>
            Specify if values are auto corrected, e.g. the WindowInfo bounds are cropped to the parent
            This enables correction, which takes a bit more time
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.InteropWindowRetrieveSettings.CacheAll">
            <summary>
                Cache all, except children, don't force reloading
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.InteropWindowRetrieveSettings.CacheAllAutoCorrect">
            <summary>
                Cache all, except children, don't force reloading, auto correct certain values
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.InteropWindowRetrieveSettings.CacheAllWithChildren">
            <summary>
                Cache all, with children, don't force reloading
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.InteropWindowRetrieveSettings.CacheAllChildZorder">
            <summary>
                Cache all, don't force reloading
            </summary>
        </member>
        <member name="T:Dapplo.Windows.Enums.WinEventHookFlags">
            <summary>
                Used for User32.SetWinEventHook
                See <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/dd373640.aspx">here</a>
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.WinEventHookFlags.OutOfContext">
            <summary>
                The callback function is not mapped into the address space of the process that generates the event.
                Because the hook function is called across process boundaries, the system must queue events.
                Although this method is asynchronous, events are guaranteed to be in sequential order.
                For more information, see Out-of-Context Hook Functions.
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.WinEventHookFlags.SkipOwnThread">
            <summary>
                Prevents this instance of the hook from receiving the events that are generated by threads in this process.
                This flag does not prevent threads from generating events.
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.WinEventHookFlags.SkipOwnProcess">
            <summary>
                Prevents this instance of the hook from receiving the events that are generated by the thread that is registering
                this hook.
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.WinEventHookFlags.InContext">
            <summary>
                The DLL that contains the callback function is mapped into the address space of the process that generates the
                event.
                With this flag, the system sends event notifications to the callback function as they occur.
                The hook function must be in a DLL when this flag is specified.
                This flag has no effect when both the calling process and the generating process are not 32-bit or 64-bit
                processes,
                or when the generating process is a console application.
                For more information, see In-Context Hook Functions.
            </summary>
        </member>
        <member name="T:Dapplo.Windows.Enums.WinEvents">
            <summary>
                Used for SetWinEventHook
                See at <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/dd318066.aspx">MSDN</a>
                and <a href="http://source.winehq.org/source/include/winuser.h">here</a>
                and <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/dd742691.aspx">here</a>
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.WinEvents.EVENT_MIN">
            <summary>
                Minimum possible value for the WinEvents
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.WinEvents.EVENT_SYSTEM_SOUND">
            <summary>
                System events
                EVENT_SYSTEM_SOUND
                Sent when a sound is played.  Currently nothing is generating this, we
                this event when a system sound (for menus, etc) is played.  Apps
                generate this, if accessible, when a private sound is played.  For
                example, if Mail plays a "New Mail" sound.
                System Sounds:
                (Generated by PlaySoundEvent in USER itself)
                hWnd            is NULL
                idObject        is OBJID_SOUND
                idChild         is sound child ID if one
                App Sounds:
                (PlaySoundEvent won't generate notification; up to app)
                hWnd + idObject gets interface pointer to Sound object
                idChild identifies the sound in question
                are going to be cleaning up the SOUNDSENTRY feature in the control panel
                and will use this at that time.  Applications implementing WinEvents
                are perfectly welcome to use it.  Clients of IAccessible* will simply
                turn around and get back a non-visual object that describes the sound.
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.WinEvents.EVENT_SYSTEM_ALERT">
            <summary>
                EVENT_SYSTEM_ALERT
                System Alerts:
                (Generated by MessageBox() calls for example)
                hWnd            is hWndMessageBox
                idObject        is OBJID_ALERT
                App Alerts:
                (Generated whenever)
                hWnd+idObject gets interface pointer to Alert
                System Alerts (indexChild of system ALERT notification)
                #define ALERT_SYSTEM_INFORMATIONAL      1       // MB_INFORMATION
                #define ALERT_SYSTEM_WARNING            2       // MB_WARNING
                #define ALERT_SYSTEM_ERROR              3       // MB_ERROR
                #define ALERT_SYSTEM_QUERY              4       // MB_QUESTION
                #define ALERT_SYSTEM_CRITICAL           5       // HardSysErrBox
                #define CALERT_SYSTEM                   6
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.WinEvents.EVENT_SYSTEM_FOREGROUND">
            <summary>
                EVENT_SYSTEM_FOREGROUND
                Sent when the foreground (active) window changes, even if it is changing
                to another window in the same thread as the previous one.
                hWnd            is hWndNewForeground
                idObject        is OBJID_WINDOW
                idChild    is INDEXID_OBJECT
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.WinEvents.EVENT_SYSTEM_MENUSTART">
            <summary>
                Menu
                hWnd            is window (top level window or popup menu window)
                idObject        is ID of control (OBJID_MENU, OBJID_SYSMENU, OBJID_SELF for popup)
                idChild         is CHILDID_SELF
                EVENT_SYSTEM_MENUSTART
                EVENT_SYSTEM_MENUEND
                For MENUSTART, hWnd+idObject+idChild refers to the control with the menu bar,
                or the control bringing up the context menu.
                Sent when entering into and leaving from menu mode (system, app bar, and
                track popups).
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.WinEvents.EVENT_SYSTEM_MENUPOPUPSTART">
            <summary>
                EVENT_SYSTEM_MENUPOPUPSTART
                EVENT_SYSTEM_MENUPOPUPEND
                Sent when a menu popup comes up and just before it is taken down.  Note
                that for a call to TrackPopupMenu(), a client will see EVENT_SYSTEM_MENUSTART
                followed almost immediately by EVENT_SYSTEM_MENUPOPUPSTART for the popup
                being shown.
                For MENUPOPUP, hWnd+idObject+idChild refers to the NEW popup coming up, not the
                parent item which is hierarchical.  You can get the parent menu/popup by
                asking for the accParent object.
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.WinEvents.EVENT_SYSTEM_CAPTURESTART">
            <summary>
                EVENT_SYSTEM_CAPTURESTART
                EVENT_SYSTEM_CAPTUREEND
                Sent when a window takes the capture and releases the capture.
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.WinEvents.EVENT_SYSTEM_MOVESIZESTART">
            <summary>
                Move Size
                EVENT_SYSTEM_MOVESIZESTART
                EVENT_SYSTEM_MOVESIZEEND
                Sent when a window enters and leaves move-size dragging mode.
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.WinEvents.EVENT_SYSTEM_CONTEXTHELPSTART">
            <summary>
                Context Help
                EVENT_SYSTEM_CONTEXTHELPSTART
                EVENT_SYSTEM_CONTEXTHELPEND
                Sent when a window enters and leaves context sensitive help mode.
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.WinEvents.EVENT_SYSTEM_DRAGDROPSTART">
            <summary>
                Drag and Drop
                EVENT_SYSTEM_DRAGDROPSTART
                EVENT_SYSTEM_DRAGDROPEND
                Send the START notification just before going into drag and drop loop.  Send
                the END notification just after canceling out.
                Note that it is up to apps and OLE to generate this, since the system
                doesn't know.  Like EVENT_SYSTEM_SOUND, it will be a while before this
                is prevalent.
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.WinEvents.EVENT_SYSTEM_DIALOGSTART">
            <summary>
                Dialog
                Send the START notification right after the dialog is completely
                initialized and visible.  Send the END right before the dialog
                is hidden and goes away.
                EVENT_SYSTEM_DIALOGSTART
                EVENT_SYSTEM_DIALOGEND
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.WinEvents.EVENT_SYSTEM_SCROLLINGSTART">
            <summary>
                EVENT_SYSTEM_SCROLLING
                EVENT_SYSTEM_SCROLLINGSTART
                EVENT_SYSTEM_SCROLLINGEND
                Sent when beginning and ending the tracking of a scrollbar in a window,
                and also for scrollbar controls.
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.WinEvents.EVENT_SYSTEM_SWITCHSTART">
            <summary>
                Alt-Tab Window
                Send the START notification right after the switch window is initialized
                and visible.  Send the END right before it is hidden and goes away.
                EVENT_SYSTEM_SWITCHSTART
                EVENT_SYSTEM_SWITCHEND
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.WinEvents.EVENT_SYSTEM_MINIMIZESTART">
            <summary>
                EVENT_SYSTEM_MINIMIZESTART
                EVENT_SYSTEM_MINIMIZEEND
                Sent when a window minimizes and just before it restores.
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.WinEvents.EVENT_SYSTEM_SWITCHER_APPGRABBED">
            <summary>
                AppGrabbed: HWND = hWnd of app thumbnail, objectID = 0, childID = 0
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.WinEvents.EVENT_SYSTEM_SWITCHER_APPOVERTARGET">
            <summary>
                OverTarget: HWND = hWnd of app thumbnail, objectID =
                1 for center
                2 for near snapped
                3 for far snapped
                4 for prune
                childID = 0
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.WinEvents.EVENT_SYSTEM_SWITCHER_APPDROPPED">
            <summary>
                Dropped: HWND = hWnd of app thumbnail, objectID = same, childID = 0
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.WinEvents.EVENT_SYSTEM_SWITCHER_CANCELLED">
            <summary>
                Cancelled: HWND = hWnd of app thumbnail, objectID = 0, childID = 0
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.WinEvents.EVENT_SYSTEM_IME_KEY_NOTIFICATION">
            <summary>
                Sent when an IME's soft key is pressed and should be echoed,
                but is not passed through the keyboard hook.
                Must not be sent when a key is sent through the keyboard hook.
                HWND             is the hWnd of the UI containing the soft key
                idChild          is the Unicode value of the character entered
                idObject         is a bitfield
                0x00000001: set if a 32-bit Unicode surrogate pair is used
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.WinEvents.EVENT_OBJECT_CREATE">
            <summary>
                Object events
                The system AND apps generate these.  The system generates these for
                real windows.  Apps generate these for objects within their window which
                act like a separate control, e.g. an item in a list view.
                When the system generate them, dwParam2 is always WMOBJID_SELF.  When
                apps generate them, apps put the has-meaning-to-the-app-only ID value
                in dwParam2.
                For all events, if you want detailed accessibility information, callers
                should
                * Call AccessibleObjectFromWindow() with the hWnd, idObject parameters
                of the event, and IID_IAccessible as the REFIID, to get back an
                IAccessible* to talk to
                * Initialize and fill in a VARIANT as VT_I4 with lVal the idChild
                parameter of the event.
                * If idChild isn't zero, call get_accChild() in the container to see
                if the child is an object in its own right.  If so, you will get
                back an IDispatch* object for the child.  You should release the
                parent, and call QueryInterface() on the child object to get its
                IAccessible*.  Then you talk directly to the child.  Otherwise,
                if get_accChild() returns you nothing, you should continue to
                use the child VARIANT.  You will ask the container for the properties
                of the child identified by the VARIANT.  In other words, the
                child in this case is accessible but not a full-blown object.
                Like a button on a titlebar which is 'small' and has no children.
                For all EVENT_OBJECT events,
                hWnd is the dude to Send the WM_GETOBJECT message to (unless NULL,
                see above for system things)
                idObject is the ID of the object that can resolve any queries a
                client might have.  It's a way to deal with windowless controls,
                controls that are just drawn on the screen in some larger parent
                window (like SDM), or standard frame elements of a window.
                idChild is the piece inside of the object that is affected.  This
                allows clients to access things that are too small to have full
                blown objects in their own right.  Like the thumb of a scrollbar.
                The hWnd/idObject pair gets you to the container, the dude you
                probably want to talk to most of the time anyway.  The idChild
                can then be passed into the acc properties to get the name/value
                of it as needed.
                Example #1:
                System propagating a listbox selection change
                EVENT_OBJECT_SELECTION
                hWnd == listbox hWnd
                idObject == OBJID_WINDOW
                idChild == new selected item, or CHILDID_SELF if
                nothing now selected within container.
                Word '97 propagating a listbox selection change
                hWnd == SDM window
                idObject == SDM ID to get at listbox 'control'
                idChild == new selected item, or CHILDID_SELF if
                nothing
                Example #2:
                System propagating a menu item selection on the menu bar
                EVENT_OBJECT_SELECTION
                hWnd == top level window
                idObject == OBJID_MENU
                idChild == ID of child menu bar item selected
                Example #3:
                System propagating a dropdown coming off of said menu bar item
                EVENT_OBJECT_CREATE
                hWnd == popup item
                idObject == OBJID_WINDOW
                idChild == CHILDID_SELF
                Example #4:
                For EVENT_OBJECT_REORDER, the object referred to by hWnd/idObject is the
                PARENT container in which the zorder is occurring.  This is because if
                one child is zordering, all of them are changing their relative zorder.
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.WinEvents.EVENT_OBJECT_SELECTION">
            <summary>
                NOTES:
                There is only one "focused" child item in a parent.  This is the place
                keystrokes are going at a given moment.  Hence only send a notification
                about where the NEW focus is going.  A NEW item getting the focus already
                implies that the OLD item is losing it.
                SELECTION however can be multiple.  Hence the different SELECTION
                notifications.  Here's when to use each:
                (1) Send a SELECTION notification in the simple single selection
                case (like the focus) when the item with the selection is
                merely moving to a different item within a container.  hWnd + ID
                is the container control, idChildItem is the new child with the
                selection.
                (2) Send a SELECTIONADD notification when a new item has simply been added
                to the selection within a container.  This is appropriate when the
                number of newly selected items is very small.  hWnd + ID is the
                container control, idChildItem is the new child added to the selection.
                (3) Send a SELECTIONREMOVE notification when a new item has simply been
                removed from the selection within a container.  This is appropriate
                when the number of newly selected items is very small, just like
                SELECTIONADD.  hWnd + ID is the container control, idChildItem is the
                new child removed from the selection.
                (4) Send a SELECTIONWITHIN notification when the selected items within a
                control have changed substantially.  Rather than propagate a large
                number of changes to reflect removal for some items, addition of
                others, just tell somebody who cares that a lot happened.  It will
                be faster an easier for somebody watching to just turn around and
                query the container control what the new bunch of selected items
                are.
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.WinEvents.EVENT_OBJECT_STATECHANGE">
            <summary>
                Examples of when to send an EVENT_OBJECT_STATECHANGE include
                * It is being enabled/disabled (USER does for windows)
                * It is being pressed/released (USER does for buttons)
                * It is being checked/unchecked (USER does for radio/check buttons)
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.WinEvents.EVENT_OBJECT_LOCATIONCHANGE">
            <summary>
                Note:
                A LOCATIONCHANGE is not sent for every child object when the parent
                changes shape/moves.  Send one notification for the topmost object
                that is changing.  For example, if the user resizes a top level window,
                USER will generate a LOCATIONCHANGE for it, but not for the menu bar,
                title bar, scrollbars, etc.  that are also changing shape/moving.
                In other words, it only generates LOCATIONCHANGE notifications for
                real windows that are moving/sizing.  It will not generate a LOCATIONCHANGE
                for every non-floating child window when the parent moves (the children are
                logically moving also on screen, but not relative to the parent).
                Now, if the app itself resizes child windows as a result of being
                sized, USER will generate LOCATIONCHANGEs for those dudes also because
                it doesn't know better.
                Note also that USER will generate LOCATIONCHANGE notifications for two
                non-window sys objects:
                (1) System caret
                (2) Cursor
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.WinEvents.EVENT_OBJECT_CONTENTSCROLLED">
            <summary>
                EVENT_OBJECT_CONTENTSCROLLED
                Sent when ending the scrolling of a window object.
                Unlike the similar event (EVENT_SYSTEM_SCROLLEND), this event will be
                associated with the scrolling window itself. There is no difference
                between horizontal or vertical scrolling.
                This event should be posted whenever scroll action is completed, including
                when it is scrolled by scroll bars, mouse wheel, or keyboard navigations.
                example:
                hWnd == window that is scrolling
                idObject == OBJID_CLIENT
                idChild == CHILDID_SELF
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.WinEvents.EVENT_OBJECT_CLOAKED">
            <summary>
                EVENT_OBJECT_CLOAKED / UNCLOAKED
                Sent when a window is cloaked or uncloaked.
                A cloaked window still exists, but is invisible to
                the user.
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.WinEvents.EVENT_OBJECT_LIVEREGIONCHANGED">
            <summary>
                EVENT_OBJECT_LIVEREGIONCHANGED
                Sent when an object that is part of a live region
                changes.  A live region is an area of an application
                that changes frequently and/or asynchronously, so
                that an assistive technology tool might want to pay
                special attention to it.
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.WinEvents.EVENT_OBJECT_HOSTEDOBJECTSINVALIDATED">
            <summary>
                EVENT_OBJECT_HOSTEDOBJECTSINVALIDATED
                Sent when a window that is hosting other Accessible
                objects changes the hosted objects.  A client may
                wish to requery to see what the new hosted objects are,
                especially if it has been monitoring events from this
                window.  A hosted object is one with a different Accessibility
                framework (MSAA or UI Automation) from its host.
                Changes in hosted objects with the *same* framework
                as the parent should be handed with the usual structural
                change events, such as EVENT_OBJECT_CREATED for MSAA.
                see above.
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.WinEvents.EVENT_OBJECT_DRAGSTART">
            <summary>
                Drag / Drop Events
                These events are used in conjunction with the
                UI Automation Drag/Drop patterns.
                For DRAGSTART, DRAGCANCEL, and DRAGCOMPLETE,
                HWND+objectID+childID refers to the object being dragged.
                For DRAGENTER, DRAGLEAVE, and DRAGDROPPED,
                HWND+objectID+childID refers to the target of the drop
                that is being hovered over.
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.WinEvents.EVENT_OBJECT_IME_SHOW">
            <summary>
                EVENT_OBJECT_IME_SHOW/HIDE
                Sent by an IME window when it has become visible or invisible.
            </summary>
        </member>
        <member name="F:Dapplo.Windows.Enums.WinEvents.EVENT_OBJECT_IME_CHANGE">
            <summary>
                EVENT_OBJECT_IME_CHANGE
                Sent by an IME window whenever it changes size or position.
            </summary>
        </member>
        <member name="T:Dapplo.Windows.Software.InstallationInformation">
            <summary>
            a helper class to evaluate the installed software
            </summary>
        </member>
        <member name="M:Dapplo.Windows.Software.InstallationInformation.MapFromRegistryKey(System.String,Microsoft.Win32.RegistryKey)">
            <summary>
            Helper method to convert from a RegistryKey object to a SoftwareDetails class
            </summary>
            <param name="subkeyName">string</param>
            <param name="subKey">RegistryKey</param>
            <returns>SoftwareDetails</returns>
        </member>
        <member name="M:Dapplo.Windows.Software.InstallationInformation.InstalledSoftware">
            <summary>
            Retrieves all the installed software
            </summary>
            <returns>IEnumerable with SoftwareDetails</returns>
        </member>
        <member name="T:Dapplo.Windows.Software.SoftwareDetails">
            <summary>
            This class contains all known fields which describe installed software, details can be found hee: <a href="https://docs.microsoft.com/en-us/windows/desktop/msi/uninstall-registry-key">Uninstall Registry Key</a>
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Software.SoftwareDetails.Id">
            <summary>
            Application's product code GUID
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Software.SoftwareDetails.AuthorizedCDFPrefix">
            <summary>
            See <a href="https://docs.microsoft.com/en-us/windows/desktop/msi/arpauthorizedcdfprefix">ARPAUTHORIZEDCDFPREFIX property</a>
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Software.SoftwareDetails.Contact">
            <summary>
            See <a href="https://docs.microsoft.com/en-us/windows/desktop/msi/arpcontact">ARPCONTACT property</a>
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Software.SoftwareDetails.Comments">
            <summary>
            Comments provided to the Add or Remove Programs control panel.
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Software.SoftwareDetails.DisplayName">
            <summary>
            ProductName property
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Software.SoftwareDetails.DisplayVersion">
            <summary>
            Derived from ProductVersion property
            See <a href="https://docs.microsoft.com/en-us/windows/desktop/msi/productversion">ProductVersion property</a>
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Software.SoftwareDetails.EstimatedSize">
            <summary>
            Determined and set by the Windows Installer.
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Software.SoftwareDetails.HelpLink">
            <summary>
            See <a href="https://docs.microsoft.com/en-us/windows/desktop/msi/arphelplink">ARPHELPLINK property</a>
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Software.SoftwareDetails.HelpTelephone">
            <summary>
            See <a href="https://docs.microsoft.com/en-us/windows/desktop/msi/arphelptelephone">ARPHELPTELEPHONE property</a>
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Software.SoftwareDetails.InstallDate">
            <summary>
            The last time this product received service.
            The value of this property is replaced each time a patch is applied or removed from the product or the /v Command-Line Option is used to repair the product.
            If the product has received no repairs or patches this property contains the time this product was installed on this computer.
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Software.SoftwareDetails.InstallLocation">
            <summary>
            See <a href="https://docs.microsoft.com/en-us/windows/desktop/msi/arpinstalllocation">ARPINSTALLLOCATION property</a>
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Software.SoftwareDetails.InstallSource">
            <summary>
            See <a href="https://docs.microsoft.com/en-us/windows/desktop/msi/sourcedir">SourceDir property</a>
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Software.SoftwareDetails.Language">
            <summary>
            See <a href="https://docs.microsoft.com/en-us/windows/desktop/msi/productlanguage">ProductLanguage property</a>
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Software.SoftwareDetails.ModifyPath">
            <summary>
            Determined and set by the Windows Installer.
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Software.SoftwareDetails.Publisher">
            <summary>
            The Manufacturer property is the name of the manufacturer for the product. It is advertised as a product property.
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Software.SoftwareDetails.UninstallString">
            <summary>
            Determined and set by Windows Installer.
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Software.SoftwareDetails.URLInfoAbout">
            <summary>
            See <a href="https://docs.microsoft.com/en-us/windows/desktop/msi/arpurlinfoabout">ARPURLINFOABOUT property</a>
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Software.SoftwareDetails.URLUpdateInfo">
            <summary>
            See <a href="https://docs.microsoft.com/en-us/windows/desktop/msi/arpurlupdateinfo">ARPURLUPDATEINFO property</a>
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Software.SoftwareDetails.Version">
            <summary>
            Derived from ProductVersion property
            See <a href="https://docs.microsoft.com/en-us/windows/desktop/msi/productversion">ProductVersion property</a>
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Software.SoftwareDetails.VersionMajor">
            <summary>
            Derived from ProductVersion property
            See <a href="https://docs.microsoft.com/en-us/windows/desktop/msi/productversion">ProductVersion property</a>
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Software.SoftwareDetails.VersionMinor">
            <summary>
            Derived from ProductVersion property
            See <a href="https://docs.microsoft.com/en-us/windows/desktop/msi/productversion">ProductVersion property</a>
            </summary>
        </member>
        <member name="M:Dapplo.Windows.Software.SoftwareDetails.ToString">
            <inheritdoc />
        </member>
        <member name="T:Dapplo.Windows.Structs.WinEventInfo">
            <summary>
                This class represents the information passed to the WinEventProc as described
                <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd373885(v=vs.85).aspx">here</a>
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Structs.WinEventInfo.EventHook">
            <summary>
                Handle to an event hook function. This value is returned by SetWinEventHook when the hook function is installed and
                is specific to each instance of the hook function.
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Structs.WinEventInfo.EventThread">
            <summary>
                Identifies the thread that generated the event, or the thread that owns the current window.
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Structs.WinEventInfo.EventTime">
            <summary>
                Specifies the time, in milliseconds, that the event was generated.
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Structs.WinEventInfo.Handle">
            <summary>
                Handle to the window that generates the event, or IntPtr.Zero if no window is associated with the event.
                For example, the mouse pointer is not associated with a window.
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Structs.WinEventInfo.IdChild">
            <summary>
                Identifies whether the event was triggered by an object or a child element of the object.
                If this value is CHILDID_SELF (0), the event was triggered by the object;
                otherwise, this value is the child ID of the element that triggered the event.
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Structs.WinEventInfo.IsSelf">
            <summary>
                Identifies whether the event was triggered by an object
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Structs.WinEventInfo.ObjectIdentifier">
            <summary>
                Handle to the window that generates the event, or IntPtr.Zero if no window is associated with the event.
                For example, the mouse pointer is not associated with a window.
            </summary>
        </member>
        <member name="P:Dapplo.Windows.Structs.WinEventInfo.WinEvent">
            <summary>
                Specifies the event that occurred.
            </summary>
        </member>
        <member name="M:Dapplo.Windows.Structs.WinEventInfo.Create(System.IntPtr,Dapplo.Windows.Enums.WinEvents,System.IntPtr,Dapplo.Windows.User32.Enums.ObjectIdentifiers,System.Int64,System.UInt64,System.UInt64)">
            <summary>
                Create a WinEventInfo instance
            </summary>
            <param name="winEventHook">
                Handle to an event hook function. This value is returned by SetWinEventHook when the hook
                function is installed and is specific to each instance of the hook function.
            </param>
            <param name="winEvent">Specifies the event that occurred. This value is one of the event constants.</param>
            <param name="hWnd">
                Handle to the window that generates the event, or NULL if no window is associated with the event.
                For example, the mouse pointer is not associated with a window.
            </param>
            <param name="idObject">
                Identifies the object associated with the event. This is one of the object identifiers or a
                custom object ID.
            </param>
            <param name="idChild">
                Identifies whether the event was triggered by an object or a child element of the object. If this
                value is CHILDID_SELF, the event was triggered by the object; otherwise, this value is the child ID of the element
                that triggered the event.
            </param>
            <param name="eventThread">Identifies the thread that generated the event, or the thread that owns the current window.</param>
            <param name="eventTime">Specifies the time, in milliseconds, that the event was generated.</param>
            <returns></returns>
        </member>
    </members>
</doc>
